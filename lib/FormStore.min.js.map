{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///FormStore.min.js","webpack:///webpack/bootstrap 1612a96f2dcaf803ffcd","webpack:///B:/job/forked/mobx-form-store/src/FormStore.js","webpack:///./~/process/browser.js","webpack:///external \"mobx\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","process","_initDefineProp","target","property","descriptor","context","Object","defineProperty","enumerable","configurable","writable","value","initializer","_classCallCheck","instance","Constructor","TypeError","_applyDecoratedDescriptor","decorators","desc","forEach","key","slice","reverse","reduce","decorator","undefined","isSame","val1","val2","Date","valueOf","observableChanged","change","store","_mobx","action","dataChanges","set","name","newValue","get","dataServer","observeComputedProperties","observeComputedPropertiesDisposers","f","getOwnPropertyNames","data","isComputedProp","options","log","disposer","observe","_ref","storeDataChanged","push","processSaveResponse","updates","response","Promise","$return","$error","$IfStatement_3","status","errorFields","error","serverError","assign","dataErrors","keys","concat","error_field","field","autoSaveInterval","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Array","from","Symbol","iterator","next","done","_step$value","_slicedToArray","err","afterSave","then","$await_9","$asyncbind","handleError","server","errorMessage","logError","_class","_descriptor","_descriptor2","_descriptor3","_descriptor4","_descriptor5","_descriptor6","_descriptor7","_descriptor8","_createClass","defineProperties","props","i","length","protoProps","staticProps","prototype","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","isArray","_typeof","obj","constructor","Function","self","catcher","result","resolver","ex","boundThen","EagerThenable","tick","_untask","_tasks","t","r","j","isThenable","inline","w","_sync","phase","_thens","resolveThen","x","rejectThen","settler","rejecter","toString","-1","0","1","guard","nextTick","setTimeout","resolve","v","reject","wrapAsyncStack","DEFAULT_SERVER_ERROR_MESSAGE","getFieldErrors","tempData","errorsArray","FormStore","idProperty","autoSaveOptions","skipPropertyBeingEdited","keepServerError","minRefreshInterval","console","bind","isReadOnly","isReady","create","beforeRefresh","afterRefresh","beforeSave","lastSync","saveQueue","Error","observable","map","asMap","observeDataPropertiesDisposer","observeDataObjectDisposer","clear","configAutoSave","reset","autorunDisposer","asyncAutorun","autorunAsync","fn","delay","autorun","save","propertyBeingEdited","hasChanges","validated","prop","temporaryDataErrors","setErrorFields","currentDataFields","temp","$IfStatement_4","$IfStatement_5","$Try_1_Post","isLoading","$Try_1_Catch","$await_10","$IfStatement_6","$await_11","$await_12","now","past","$await_13","_this","saveOptions","arguments","_saveOptions$allowCre","allowCreate","_saveOptions$saveAll","saveAll","_saveOptions$skipProp","_saveOptions$keepServ","$IfStatement_7","$Try_2_Post","isSaving","$Try_2_Catch","$IfStatement_8","$await_14","saveNotification","active","$await_16","$await_15","toJSON","toJS","$await_17","errors","isInProgress","canSave","size","computed","getOwnPropertyDescriptor","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","e","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","noop","args","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"FormStore.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"mobx\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"FormStore\", [\"mobx\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FormStore\"] = factory(require(\"mobx\"));\n\telse\n\t\troot[\"FormStore\"] = factory(root[\"mobx\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"mobx\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"FormStore\", [\"mobx\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FormStore\"] = factory(require(\"mobx\"));\n\telse\n\t\troot[\"FormStore\"] = factory(root[\"mobx\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _mobx = __webpack_require__(2);\n\t\n\tfunction _initDefineProp(target, property, descriptor, context) {\n\t  if (!descriptor) return;\n\t  Object.defineProperty(target, property, {\n\t    enumerable: descriptor.enumerable,\n\t    configurable: descriptor.configurable,\n\t    writable: descriptor.writable,\n\t    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n\t  });\n\t}\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n\t  var desc = {};\n\t  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n\t    desc[key] = descriptor[key];\n\t  });\n\t  desc.enumerable = !!desc.enumerable;\n\t  desc.configurable = !!desc.configurable;\n\t\n\t  if ('value' in desc || desc.initializer) {\n\t    desc.writable = true;\n\t  }\n\t\n\t  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n\t    return decorator(target, property, desc) || desc;\n\t  }, desc);\n\t\n\t  if (context && desc.initializer !== void 0) {\n\t    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t    desc.initializer = undefined;\n\t  }\n\t\n\t  if (desc.initializer === void 0) {\n\t    Object['define' + 'Property'](target, property, desc);\n\t    desc = null;\n\t  }\n\t\n\t  return desc;\n\t}\n\t\n\tfunction _initializerWarningHelper(descriptor, context) {\n\t  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n\t}\n\t\n\tFunction.prototype.$asyncbind = function anonymous(self, catcher) {\n\t  var resolver = this;\n\t\n\t  if (catcher === true) {\n\t    if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {\n\t      var _tasks = [];\n\t\n\t      if (!tick) {\n\t        try {\n\t          tick = process.nextTick;\n\t        } catch (ex) {\n\t          tick = function tick(p) {\n\t            setTimeout(p, 0);\n\t          };\n\t        }\n\t      }\n\t\n\t      function _untask() {\n\t        for (var i = 0; i < _tasks.length; i += 2) {\n\t          var t = _tasks[i + 1],\n\t              r = _tasks[i];\n\t\n\t          for (var j = 0; j < t.length; j++) {\n\t            t[j].call(null, r);\n\t          }\n\t        }\n\t\n\t        _tasks = [];\n\t      }\n\t\n\t      function isThenable(obj) {\n\t        return obj && obj instanceof Object && typeof obj.then === 'function';\n\t      }\n\t\n\t      function EagerThenable(resolver) {\n\t        function done(inline) {\n\t          var w;\n\t          if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;\n\t\n\t          _tasks.push(result, w);\n\t\n\t          _thens = [[], []];\n\t          if (_tasks.length === 2) inline ? _untask() : tick(_untask);\n\t        }\n\t\n\t        function resolveThen(x) {\n\t          if (phase >= 0) return;\n\t          if (isThenable(x)) return x.then(resolveThen, rejectThen);\n\t          phase = 0;\n\t          result = x;\n\t          done(true);\n\t        }\n\t\n\t        function rejectThen(x) {\n\t          if (phase >= 0) return;\n\t          if (isThenable(x)) return x.then(resolveThen, rejectThen);\n\t          phase = 1;\n\t          result = x;\n\t          done(true);\n\t        }\n\t\n\t        function settler(resolver, rejecter) {\n\t          _thens[0].push(resolver);\n\t\n\t          _thens[1].push(rejecter);\n\t\n\t          done();\n\t        }\n\t\n\t        function toString() {\n\t          return 'EagerThenable{' + {\n\t            '-1': 'pending',\n\t            0: 'resolved',\n\t            1: 'rejected'\n\t          }[phase] + '}=' + result.toString();\n\t        }\n\t\n\t        function guard() {\n\t          try {\n\t            resolver.call(null, resolveThen, rejectThen);\n\t          } catch (ex) {\n\t            rejectThen(ex);\n\t          }\n\t        }\n\t\n\t        this.then = settler;\n\t        this.toString = toString;\n\t        var _thens = [[], []],\n\t            _sync = true,\n\t            phase = -1,\n\t            result;\n\t        guard();\n\t        _sync = false;\n\t        done();\n\t      }\n\t\n\t      EagerThenable.resolve = function (v) {\n\t        return isThenable(v) ? v : {\n\t          then: function then(resolve, reject) {\n\t            return resolve(v);\n\t          }\n\t        };\n\t      };\n\t\n\t      return EagerThenable;\n\t    }();\n\t    return new Function.prototype.$asyncbind.EagerThenable(boundThen);\n\t  }\n\t\n\t  if (catcher) {\n\t    if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);\n\t    return then;\n\t  }\n\t\n\t  function then(result, error) {\n\t    try {\n\t      return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);\n\t    } catch (ex) {\n\t      return (error || catcher)(ex);\n\t    }\n\t  }\n\t\n\t  function boundThen(result, error) {\n\t    return resolver.call(self, result, error);\n\t  }\n\t\n\t  boundThen.then = boundThen;\n\t  return boundThen;\n\t};\n\t\n\tvar DEFAULT_SERVER_ERROR_MESSAGE = 'Lost connection to server';\n\t\n\tvar getFieldErrors = function getFieldErrors(tempData) {\n\t  var errorsArray = [];\n\t  Object.keys(tempData).forEach(function (key) {\n\t    if (tempData[key] && _typeof(tempData[key]) === 'object') {\n\t      return getFieldErrors(tempData[key]);\n\t    } else if (tempData[key]) {\n\t      errorsArray.push(tempData[key]);\n\t    }\n\t    return tempData[key];\n\t  });\n\t  return errorsArray;\n\t};\n\t\n\tfunction isSame(val1, val2) {\n\t  /* eslint-disable eqeqeq */\n\t  return val1 == val2 || val1 instanceof Date && val2 instanceof Date && val1.valueOf() == val2.valueOf();\n\t  /* eslint-enable eqeqeq */\n\t}\n\t\n\t/**\n\t * Observes data and if changes come, add them to dataChanges,\n\t * unless it resets back to dataServer value, then clear that change\n\t * @this {FormStore}\n\t * @param {Object} change\n\t * @param {String} change.name - name of property that changed\n\t * @param {*} change.newValue\n\t */\n\tfunction observableChanged(change) {\n\t  var store = this;\n\t  (0, _mobx.action)(function () {\n\t    store.dataChanges.set(change.name, change.newValue);\n\t\n\t    if (store.isSame(store.dataChanges.get(change.name), store.dataServer[change.name])) {\n\t      store.dataChanges.delete(change.name);\n\t    }\n\t  })();\n\t}\n\t\n\t/**\n\t * Sets up observation on all computed data properties, if any\n\t * @param {FormStore} store\n\t */\n\tfunction observeComputedProperties(store) {\n\t  store.observeComputedPropertiesDisposers.forEach(function (f) {\n\t    return f();\n\t  });\n\t  store.observeComputedPropertiesDisposers = [];\n\t  (0, _mobx.action)(function () {\n\t    Object.getOwnPropertyNames(store.data).forEach(function (key) {\n\t      if ((0, _mobx.isComputedProp)(store.data, key)) {\n\t        store.options.log('[' + store.options.name + '] Observing computed property: ' + key);\n\t        var disposer = (0, _mobx.observe)(store.data, key, function (_ref) {\n\t          var newValue = _ref.newValue;\n\t          return store.storeDataChanged({ name: key, newValue: newValue });\n\t        });\n\t        store.observeComputedPropertiesDisposers.push(disposer);\n\t        // add or delete from dataChanges depending on whether value is same as in dataServer:\n\t        store.storeDataChanged({ name: key, newValue: store.data[key] });\n\t      }\n\t    });\n\t  })();\n\t}\n\t\n\t/**\n\t * Records successfully saved data as saved\n\t * and reverts fields server indicates to be in error\n\t * @param {FormStore} store\n\t * @param {Object} updates - what we sent to the server\n\t * @param {Object} response\n\t * @param {String} [response.data] - optional updated data to merge into the store (server.create can return id here)\n\t * @param {String} [response.status] - 'error' indicates one or more fields were invalid and not saved.\n\t * @param {String|Object} [response.error] - either a single error message to show to user if string or field-specific error messages if object\n\t * @param {String|Array} [response.error_field] - name of the field (or array of field names) in error\n\t * If autoSave is enabled, any field in error_field for which there is no error message in response.error will be reverted\n\t * to prevent autoSave from endlessly trying to save the changed field.\n\t * @returns response.status\n\t */\n\tfunction processSaveResponse(store, updates, response) {\n\t  return new Promise(function ($return, $error) {\n\t    // TODO add correct updates deleting after errors. updates[field] inner objects\n\t    store.options.log('[' + store.options.name + '] Response received from server.');\n\t\n\t    if (response.status === 'error') {\n\t      (0, _mobx.action)(function () {\n\t        var errorFields = [];\n\t        if (response.error) {\n\t          if (typeof response.error === 'string') {\n\t            store.serverError = response.error;\n\t          } else {\n\t            Object.assign(store.dataErrors, response.error);\n\t            errorFields = Object.keys(response.error);\n\t          }\n\t        }\n\t\n\t        // Supports an array of field names in error_field or a string\n\t        errorFields = errorFields.concat(response.error_field);\n\t        errorFields.forEach(function (field) {\n\t          if (store.options.autoSaveInterval && !store.dataErrors[field] && store.isSame(updates[field], store.data[field])) {\n\t            store.data[field] = store.dataServer[field]; // revert or it'll keep trying to autosave it\n\t          }\n\t          delete updates[field]; // don't save it as the new dataServer value\n\t        });\n\t      })();\n\t    } else {\n\t      store.serverError = null;\n\t    }\n\t\n\t    Object.assign(store.dataServer, updates);\n\t\n\t    (0, _mobx.action)(function () {\n\t      if (response.data) {\n\t        Object.assign(store.dataServer, response.data);\n\t        Object.assign(store.data, response.data);\n\t      }\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = Array.from(store.dataChanges)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var _step$value = _slicedToArray(_step.value, 2),\n\t              key = _step$value[0],\n\t              value = _step$value[1];\n\t\n\t          if (store.isSame(value, store.dataServer[key])) {\n\t            store.dataChanges.delete(key);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    })();\n\t\n\t    function $IfStatement_3() {\n\t\n\t      return $return(response.status);\n\t    }\n\t\n\t    if (typeof store.options.afterSave === 'function') {\n\t      return store.options.afterSave(store, updates, response).then(function ($await_9) {\n\t        return $IfStatement_3.call(this);\n\t      }.$asyncbind(this, $error), $error);\n\t    }return $IfStatement_3.call(this);\n\t  }.$asyncbind(this));\n\t}\n\t\n\t/**\n\t * @param {FormStore} store\n\t * @param {Error} err\n\t */\n\tfunction handleError(store, err) {\n\t  if (typeof store.options.server.errorMessage === 'function') {\n\t    store.serverError = store.options.server.errorMessage(err);\n\t  } else {\n\t    store.serverError = store.options.server.errorMessage;\n\t  }\n\t\n\t  store.options.logError(err);\n\t}\n\t\n\tvar FormStore = (_class = function () {\n\t  // stores validation error message if any for each field (data structure is identical to data)\n\t  // stores both communication error and any explicit response.error returned to save\n\t\n\t  /** @private */\n\t  // To support both Mobx 2.2+ and 3+, this is now done in constructor:\n\t  // @observable dataChanges = asMap(); // changes that will be sent to server\n\t\n\t  /** @private */\n\t\n\t  /** @private */\n\t\n\t\n\t  /** @private */\n\t\n\t  /**\n\t   * @private\n\t   * @type {Array<Function>}\n\t   */\n\t\n\t  /** @private */\n\t\n\t\n\t  /**\n\t   * @private\n\t   * @type {null|Date}\n\t   */\n\t  function FormStore(options, data) {\n\t    _classCallCheck(this, FormStore);\n\t\n\t    this.options = {\n\t      name: 'FormStore', // used in log statements\n\t      idProperty: null,\n\t      autoSaveOptions: { skipPropertyBeingEdited: true, keepServerError: true },\n\t      autoSaveInterval: 0, // in ms\n\t      minRefreshInterval: 0, // in ms\n\t      log: function noop() {},\n\t      logError: console.error.bind(console), // eslint-disable-line\n\t      /** @type {Boolean|function(object): Boolean} passed status object */\n\t      isReadOnly: function isReadOnly(status) {\n\t        return !status.isReady;\n\t      },\n\t      server: {\n\t        /** @type {undefined|function: Promise|Object} - MUST resolve to an object with all data properties present even if all have null values */\n\t        get: undefined,\n\t        /** @type {undefined|function(object): Promise|Object} passed updates object - see processSaveResponse for expected error response properties */\n\t        set: undefined,\n\t        /** @type {undefined|function(object}: Promise|Object} passed updates object - see processSaveResponse for expected error response properties */\n\t        create: undefined,\n\t        /** @type {String|function(error): String} passed error object */\n\t        errorMessage: DEFAULT_SERVER_ERROR_MESSAGE\n\t      },\n\t      /** @type {undefined|function(FormStore): Promise|Boolean} passed store instance - if it returns false, no refresh will be performed */\n\t      beforeRefresh: undefined,\n\t      /** @type {undefined|function(FormStore): Promise} passed store instance */\n\t      afterRefresh: undefined,\n\t      /** @type {undefined|function(FormStore, object, object): Promise|Boolean} passed store instance, updates object and saveOptions object,\n\t       * (i.e. with skipPropertyBeingEdited, etc booleans) - if it returns false, no save will be performed */\n\t      beforeSave: undefined,\n\t      /** @type {undefined|function(FormStore, object, object): Promise} passed store instance, updates object and response object\n\t       * - updates object will already have fields removed from it that response indicates are in error */\n\t      afterSave: undefined\n\t    };\n\t    this.lastSync = null;\n\t    this.saveQueue = Promise.resolve();\n\t    this.observeComputedPropertiesDisposers = [];\n\t\n\t    _initDefineProp(this, 'isReady', _descriptor, this);\n\t\n\t    _initDefineProp(this, 'isLoading', _descriptor2, this);\n\t\n\t    _initDefineProp(this, 'isSaving', _descriptor3, this);\n\t\n\t    _initDefineProp(this, 'serverError', _descriptor4, this);\n\t\n\t    this.dataServer = {};\n\t\n\t    _initDefineProp(this, 'data', _descriptor5, this);\n\t\n\t    _initDefineProp(this, 'dataErrors', _descriptor6, this);\n\t\n\t    _initDefineProp(this, 'saveNotification', _descriptor7, this);\n\t\n\t    _initDefineProp(this, 'propertyBeingEdited', _descriptor8, this);\n\t\n\t    this.isSame = isSame;\n\t\n\t    var store = this;\n\t    Object.assign(store.options, options);\n\t    if (!data && typeof store.options.server.get !== 'function') {\n\t      throw new Error('options must specify server get function or supply initial data object to constructor');\n\t    }\n\t    if (!_typeof(store.options.server.create) !== 'function' && typeof store.options.server.set !== 'function') {\n\t      throw new Error('options must specify server set and/or create function(s)');\n\t    }\n\t    store.options.server.errorMessage = store.options.server.errorMessage || DEFAULT_SERVER_ERROR_MESSAGE;\n\t\n\t    // Supports both Mobx 3+ (observable.map) and 2.x (asMap) without deprecation warnings:\n\t    store.dataChanges = _mobx.observable.map ? _mobx.observable.map() : (0, _mobx.asMap)(); // changes that will be sent to server\n\t\n\t    // register observe for changes to properties in store.data as well as to complete replacement of store.data object\n\t    store.storeDataChanged = observableChanged.bind(store);\n\t    store.observeDataPropertiesDisposer = (0, _mobx.observe)(store.data, store.storeDataChanged);\n\t    store.observeDataObjectDisposer = (0, _mobx.observe)(store, 'data', function () {\n\t      store.observeDataPropertiesDisposer && store.observeDataPropertiesDisposer();\n\t      store.observeDataPropertiesDisposer = (0, _mobx.observe)(store.data, store.storeDataChanged);\n\t\n\t      store.dataChanges.clear();\n\t      (0, _mobx.action)(function () {\n\t        Object.keys(store.data).forEach(function (key) {\n\t          var value = store.data[key];\n\t          if (!store.isSame(value, store.dataServer[key])) {\n\t            store.dataChanges.set(key, value);\n\t          }\n\t        });\n\t        observeComputedProperties(store);\n\t      })();\n\t    });\n\t\n\t    store.configAutoSave(store.options.autoSaveInterval, store.options.autoSaveOptions);\n\t\n\t    if (data) {\n\t      store.dataServer = data;\n\t      store.reset();\n\t      observeComputedProperties(store);\n\t      store.isReady = true;\n\t    }\n\t  }\n\t\n\t  /**\n\t   *  disposes of all internal observation/autoruns so this instance can be garbage-collected.\n\t   */\n\t  // property currently being edited as set by startEditing()\n\t\n\t  // active is set to true right after a save is completed and status is set to response.status\n\t  // this allows a confirmation message to be shown to user and to drive its dismissal,\n\t  // UI can set this observable's active property back to false.\n\t  // data returned by the server (kept for checking old values)\n\t\n\t  /** @private */\n\t  // true after initial data load (refresh) has completed\n\t  /** @private */\n\t\n\t  /** @private */\n\t\n\t  /** @private */\n\t\n\t  /** @private */\n\t\n\t  /** @private */\n\t\n\t\n\t  _createClass(FormStore, [{\n\t    key: 'dispose',\n\t    value: function dispose() {\n\t      var store = this;\n\t      store.autorunDisposer && store.autorunDisposer();\n\t      store.observeDataObjectDisposer && store.observeDataObjectDisposer();\n\t      store.observeDataPropertiesDisposer && store.observeDataPropertiesDisposer();\n\t      store.observeComputedPropertiesDisposers.forEach(function (f) {\n\t        return f();\n\t      });\n\t      store.autorunDisposer = undefined;\n\t      store.observeDataObjectDisposer = undefined;\n\t      store.observeDataPropertiesDisposer = undefined;\n\t      store.observeComputedPropertiesDisposers = [];\n\t    }\n\t\n\t    /**\n\t     * Configures and enables or disables auto-save\n\t     * @param {Number} autoSaveInterval - (in ms) - if non-zero autosave will be enabled, otherwise disabled\n\t     * @param {Object} [autoSaveOptions] - overrides the default autoSaveOptions if provided\n\t     */\n\t\n\t  }, {\n\t    key: 'configAutoSave',\n\t    value: function configAutoSave(autoSaveInterval, autoSaveOptions) {\n\t      var store = this;\n\t      store.autorunDisposer && store.autorunDisposer();\n\t      store.options.autoSaveInterval = autoSaveInterval;\n\t      store.options.autoSaveOptions = autoSaveOptions || store.options.autoSaveOptions;\n\t\n\t      // auto-save by observing dataChanges keys\n\t      if (store.options.autoSaveInterval) {\n\t        // Supports both Mobx <=3 (autorunAsync) and Mobx 4+\n\t        // (ObservableMap keys no longer returning an Array is used to detect Mobx 4+,\n\t        // because in non-production build autorunAsync exists in 4.x to issue deprecation error)\n\t        var asyncAutorun = Array.isArray(store.dataChanges.keys()) ? _mobx.autorunAsync : function (fn, delay) {\n\t          return (0, _mobx.autorun)(fn, { delay: delay });\n\t        };\n\t\n\t        store.autorunDisposer = asyncAutorun(function () {\n\t          if ((!store.options.idProperty || store.data[store.options.idProperty]) && Array.from(store.dataChanges).length) {\n\t            store.options.log('[' + store.options.name + '] Auto-save started...');\n\t            store.save(store.options.autoSaveOptions);\n\t          }\n\t        }, store.options.autoSaveInterval);\n\t      } else {\n\t        store.autorunDisposer = undefined;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Marks data property as edit-in-progress and therefore it should not be autosaved - to be called on field focus\n\t     * @param {String|Array} name - field/property name (Array format supports json schema forms)\n\t     */\n\t\n\t  }, {\n\t    key: 'startEditing',\n\t    value: function startEditing(name) {\n\t      var store = this;\n\t      store.propertyBeingEdited = Array.isArray(name) ? name[0] : name;\n\t    }\n\t\n\t    // to be called on field blur, any field name parameter is ignored\n\t\n\t  }, {\n\t    key: 'stopEditing',\n\t    value: function stopEditing() {\n\t      var store = this;\n\t      store.propertyBeingEdited = null;\n\t      if (store.status.hasChanges) {\n\t        // This will trigger autorun in case it already ran while we were editing:\n\t        (0, _mobx.action)(function () {\n\t          // In MobX 4+, ObservableMap.keys() returns an Iterable, not an array\n\t          var key = Array.from(store.dataChanges)[0][0];\n\t          var value = store.dataChanges.get(key);\n\t          store.dataChanges.delete(key);\n\t          store.dataChanges.set(key, value);\n\t        })();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Returns the value of a field/property, optionally returning the last saved value for not validated/in progress fields\n\t     * Without validated:true, using this function is not necessary, can just access store.data[name].\n\t     * @param {String|Array} name - field/property name (Array format supports json schema forms)\n\t     * @param {Boolean} [validated] - only return validated value, i.e. if it's in error, fallback to dataServer\n\t     * @param {Boolean} [skipPropertyBeingEdited] - used only when validated is true to again fallback to dataServer\n\t     * @returns {*}\n\t     */\n\t\n\t  }, {\n\t    key: 'getValue',\n\t    value: function getValue(name, validated, skipPropertyBeingEdited) {\n\t      var store = this;\n\t      var prop = Array.isArray(name) ? name[0] : name;\n\t      if (validated) {\n\t        // check if property is being edited or invalid\n\t        if (skipPropertyBeingEdited && prop === store.propertyBeingEdited || store.dataErrors[prop]) {\n\t          return store.dataServer[prop];\n\t        }\n\t      }\n\t      return store.data[prop];\n\t    }\n\t\n\t    // Returns the last saved (or server-provided) set of data\n\t    // - in an afterSave callback it already includes merged updates that were not in error\n\t\n\t  }, {\n\t    key: 'getSavedData',\n\t    value: function getSavedData() {\n\t      var store = this;\n\t      return store.dataServer;\n\t    }\n\t\n\t    /**\n\t     * @returns {{errors: Array<String>, isReady: Boolean, isInProgress: Boolean, canSave: Boolean, hasChanges: Boolean, isReadOnly: Boolean}}\n\t     * errors is an array of any serverError plus all the error messages from all fields (in no particular order)\n\t     * (serverError is either the string returned in response.error or a communication error and is cleared on every refresh and save)\n\t     * isReady indicates initial data load (refresh) has been completed and user can start entering data\n\t     * isInProgress indicates either a refresh or a save is in progress\n\t     * canSave is true when no refresh or save is in progress and there are no validation errors\n\t     * hasChanges is true when one or more data properties has a value that's different from last-saved/server-loaded data.\n\t     * isReadOnly by default is true when isReady is false but can be set to the return value of an\n\t     *            optional callback to which this status object (without isReadOnly) is passed\n\t     */\n\t\n\t  }, {\n\t    key: 'reset',\n\t\n\t\n\t    /**\n\t     * Copies dataServer into data and resets the error observable.\n\t     * Mostly for internal use by refresh().\n\t     * @param {Object} [data] Optionally set store.data to this object instead of copying dataServer\n\t     */\n\t    value: function reset(data) {\n\t      var store = this;\n\t\n\t      (0, _mobx.action)(function () {\n\t        store.data = data || Object.assign({}, store.dataServer);\n\t\n\t        // setup error observable\n\t        var temporaryDataErrors = {};\n\t        var setErrorFields = function setErrorFields(currentDataFields, temp) {\n\t          Object.keys(currentDataFields).forEach(function (key) {\n\t            if (currentDataFields[key] && _typeof(currentDataFields[key]) === 'object') {\n\t              temp[key] = {};\n\t              return setErrorFields(currentDataFields[key], temp[key]);\n\t            }\n\t            temp[key] = null;\n\t            return temp[key];\n\t          });\n\t        };\n\t        setErrorFields(store.data, temporaryDataErrors);\n\t        store.dataErrors = temporaryDataErrors;\n\t      })();\n\t    }\n\t\n\t    /**\n\t     * Loads data from server unless a refresh was performed within the last minRefreshInterval (i.e. 15 minutes).\n\t     * If there are pending (and ready to save) changes, triggers save instead and 'resets the clock' on minRefreshInterval.\n\t     * For a store with idProperty defined, if that data property is falsy, loads from server only the very first time refresh() is called.\n\t     * @returns {Promise|Boolean} resolves to true if refresh actually performed, false if skipped\n\t     */\n\t\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh() {\n\t      return new Promise(function ($return, $error) {\n\t        var store, now, past, result;\n\t        store = this;\n\t\n\t        if (!store.options.server.get || store.isReady && store.options.idProperty && !store.data[store.options.idProperty]) {\n\t          return $return(false);\n\t        }\n\t        store.options.log('[' + store.options.name + '] Starting data refresh...');\n\t\n\t        if (store.isLoading) {\n\t          store.options.log('[' + store.options.name + '] Data is already being refreshed.');\n\t          return $return(false);\n\t        }\n\t\n\t        now = new Date();\n\t        past = new Date(Date.now() - store.options.minRefreshInterval);\n\t\n\t\n\t        // check if lastSync is between now and 15 minutes ago\n\t        if (past < store.lastSync && store.lastSync <= now) {\n\t          store.options.log('[' + store.options.name + '] Data refreshed within last ' + store.options.minRefreshInterval / 1000 + ' seconds.');\n\t          return $return(false);\n\t        }\n\t\n\t        function $IfStatement_4() {\n\t          function $IfStatement_5() {\n\t\n\t            store.options.log('[' + store.options.name + '] Refreshing data...');\n\t            store.isLoading = true;\n\t\n\t            function $Try_1_Post() {\n\t\n\t              store.isLoading = false;\n\t              return $return(true);\n\t            }\n\t\n\t            var $Try_1_Catch = function (err) {\n\t              handleError(store, err);\n\t              return $Try_1_Post.call(this);\n\t            }.$asyncbind(this, $error);\n\t\n\t            try {\n\t              return store.options.server.get().then(function ($await_10) {\n\t                result = $await_10;\n\t\n\t                store.options.log('[' + store.options.name + '] Data received from server.');\n\t\n\t                (0, _mobx.action)(function () {\n\t                  store.dataServer = result;\n\t                  store.serverError = null;\n\t                  store.lastSync = new Date();\n\t                  store.reset();\n\t                })();\n\t\n\t                function $IfStatement_6() {\n\t\n\t                  observeComputedProperties(store);\n\t\n\t                  store.options.log('[' + store.options.name + '] Refresh finished.');\n\t                  if (!store.isReady) store.isReady = true;\n\t                  return $Try_1_Post.call(this);\n\t                }\n\t\n\t                if (typeof store.options.afterRefresh === 'function') {\n\t                  return store.options.afterRefresh(store).then(function ($await_11) {\n\t                    return $IfStatement_6.call(this);\n\t                  }.$asyncbind(this, $Try_1_Catch), $Try_1_Catch);\n\t                }return $IfStatement_6.call(this);\n\t              }.$asyncbind(this, $Try_1_Catch), $Try_1_Catch);\n\t            } catch (err) {\n\t              $Try_1_Catch(err)\n\t            }\n\t          }\n\t\n\t          if (typeof store.options.beforeRefresh === 'function') {\n\t            return store.options.beforeRefresh(store).then(function ($await_12) {\n\t              if ($await_12 === false) {\n\t                return $return(false);\n\t              }\n\t              return $IfStatement_5.call(this);\n\t            }.$asyncbind(this, $error), $error);\n\t          }return $IfStatement_5.call(this);\n\t        }\n\t\n\t        if (store.status.hasChanges && (!store.options.idProperty || store.data[store.options.idProperty])) {\n\t          store.options.log('[' + store.options.name + '] Unsaved changes detected...');\n\t\n\t          return store.save().then(function ($await_13) {\n\t            if ($await_13) {\n\t              store.options.log('[' + store.options.name + '] Postponing refresh for ' + store.options.minRefreshInterval / 1000 + ' seconds.');\n\t              store.lastSync = new Date();\n\t              return $return(false);\n\t            }\n\t            return $IfStatement_4.call(this);\n\t          }.$asyncbind(this, $error), $error);\n\t        }return $IfStatement_4.call(this);\n\t      }.$asyncbind(this));\n\t    }\n\t\n\t    /**\n\t     * Sends ready-to-save data changes to the server (normally using server.set unless it's undefined, then with server.create)\n\t     * For a store with idProperty defined when that property is falsy and allowCreate=true, uses server.create instead.\n\t     * Calls to save() while one is in progress are queued.\n\t     * @param {Object} saveOptions - the object as a whole is also passed to the beforeSave callback\n\t     * @param {Boolean} [saveOptions.allowCreate=false] - for a store with idProperty defined, this must be true\n\t     *                                                    for the save to actually be performed when that property is falsy.\n\t     * @param {Boolean} [saveOptions.saveAll=false] - normally save only sends changes and if no changes, no save is done.\n\t     *                                                if saveAll=true, sends the full data object regardless of changes.\n\t     * @param {Boolean} [saveOptions.skipPropertyBeingEdited=false] - true in an auto-save\n\t     * @param {Boolean} [saveOptions.keepServerError=false] - true in an auto-save\n\t     * @returns {Promise|Boolean} resolves to true if save actually performed, false if skipped\n\t     */\n\t\n\t  }, {\n\t    key: 'save',\n\t    value: function save() {\n\t      var _this = this;\n\t\n\t      var saveOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var _saveOptions$allowCre = saveOptions.allowCreate,\n\t          allowCreate = _saveOptions$allowCre === undefined ? false : _saveOptions$allowCre,\n\t          _saveOptions$saveAll = saveOptions.saveAll,\n\t          saveAll = _saveOptions$saveAll === undefined ? false : _saveOptions$saveAll,\n\t          _saveOptions$skipProp = saveOptions.skipPropertyBeingEdited,\n\t          skipPropertyBeingEdited = _saveOptions$skipProp === undefined ? false : _saveOptions$skipProp,\n\t          _saveOptions$keepServ = saveOptions.keepServerError,\n\t          keepServerError = _saveOptions$keepServ === undefined ? false : _saveOptions$keepServ;\n\t\n\t      var store = this;\n\t\n\t      store.saveQueue = store.saveQueue.then(function () {\n\t        return new Promise(function ($return, $error) {\n\t          var updates = void 0;\n\t\n\t          if (store.options.idProperty && !store.data[store.options.idProperty] && !allowCreate) {\n\t            return $return(false);\n\t          }\n\t          store.options.log('[' + store.options.name + '] Starting data save...');\n\t\n\t          if (saveAll) {\n\t            updates = {};\n\t            Object.getOwnPropertyNames(store.data).forEach(function (key) {\n\t              if (key[0] !== '$') updates[key] = store.data[key];\n\t            });\n\t          } else {\n\t            // Mobx 4+ toJS() exports a Map, not an Object and toJSON is the 'legacy' method to export an Object\n\t            updates = store.dataChanges.toJSON ? store.dataChanges.toJSON() : store.dataChanges.toJS();\n\t\n\t            if (Object.keys(updates).length === 0) {\n\t              store.options.log('[' + store.options.name + '] No changes to save.');\n\t              return $return(false);\n\t            }\n\t\n\t            // check if we have property currently being edited in changes\n\t            // or if a property has an error\n\t            Object.keys(updates).forEach(function (property) {\n\t              if (skipPropertyBeingEdited && property === store.propertyBeingEdited) {\n\t                store.options.log('[' + store.options.name + '] Property \"' + property + '\" is being edited.');\n\t                delete updates[property];\n\t                return;\n\t              }\n\t\n\t              if (store.dataErrors[property]) {\n\t                store.options.log('[' + store.options.name + '] Property \"' + property + '\" is not validated.');\n\t                delete updates[property];\n\t                return;\n\t              }\n\t\n\t              if (store.isSame(updates[property], store.dataServer[property])) {\n\t                store.options.log('[' + store.options.name + '] Property \"' + property + '\" is same as on the server.');\n\t                delete updates[property];\n\t                store.dataChanges.delete(property);\n\t              }\n\t            });\n\t\n\t            if (Object.keys(updates).length === 0) {\n\t              store.options.log('[' + store.options.name + '] No changes ready to save.');\n\t              return $return(false);\n\t            }\n\t          }\n\t\n\t          function $IfStatement_7() {\n\t\n\t            store.options.log('[' + store.options.name + '] Saving data...');\n\t            store.options.log(updates);\n\t            store.isSaving = true;\n\t\n\t            function $Try_2_Post() {\n\t\n\t              store.isSaving = false;\n\t              return $return(true);\n\t            }\n\t\n\t            var $Try_2_Catch = function (err) {\n\t              handleError(store, err);\n\t              return $Try_2_Post.call(this);\n\t            }.$asyncbind(this, $error);\n\t\n\t            try {\n\t              var $IfStatement_8 = function $IfStatement_8() {\n\t                return processSaveResponse(store, updates, response).then(function ($await_14) {\n\t\n\t                  store.saveNotification.status = $await_14;\n\t                  store.saveNotification.active = true;\n\t\n\t                  store.options.log('[' + store.options.name + '] Save finished.');\n\t                  return $Try_2_Post.call(this);\n\t                }.$asyncbind(this, $Try_2_Catch), $Try_2_Catch);\n\t              };\n\t\n\t              var response = void 0;\n\t\n\t              if (!keepServerError) {\n\t                store.serverError = null;\n\t              }\n\t\n\t              if (store.options.server.set && (!store.options.idProperty || !store.options.server.create || store.data[store.options.idProperty])) {\n\t                return store.options.server.set(updates).then(function ($await_15) {\n\t                  response = $await_15;\n\t                  return $IfStatement_8.call(this);\n\t                }.$asyncbind(this, $Try_2_Catch), $Try_2_Catch);\n\t              } else {\n\t                return store.options.server.create(updates).then(function ($await_16) {\n\t                  response = $await_16;\n\t                  return $IfStatement_8.call(this);\n\t                }.$asyncbind(this, $Try_2_Catch), $Try_2_Catch);\n\t              }\n\t            } catch (err) {\n\t              $Try_2_Catch(err)\n\t            }\n\t          }\n\t\n\t          if (typeof store.options.beforeSave === 'function') {\n\t            return store.options.beforeSave(store, updates, saveOptions).then(function ($await_17) {\n\t              if ($await_17 === false) {\n\t                return $return(false);\n\t              }\n\t              return $IfStatement_7.call(this);\n\t            }.$asyncbind(this, $error), $error);\n\t          }return $IfStatement_7.call(this);\n\t        }.$asyncbind(_this));\n\t      });\n\t\n\t      return store.saveQueue;\n\t    }\n\t  }, {\n\t    key: 'status',\n\t    get: function get() {\n\t      var store = this;\n\t      var errors = [];\n\t\n\t      if (store.serverError) {\n\t        errors = [store.serverError];\n\t      }\n\t\n\t      errors = errors.concat(getFieldErrors(store.dataErrors));\n\t\n\t      var status = {\n\t        errors: errors,\n\t        isReady: store.isReady,\n\t        isInProgress: store.isLoading || store.isSaving,\n\t        canSave: !store.isLoading && !store.isSaving && (store.serverError ? errors.length === 1 : errors.length === 0),\n\t        hasChanges: !!store.dataChanges.size\n\t      };\n\t      if (typeof store.options.isReadOnly === 'function') {\n\t        status.isReadOnly = store.options.isReadOnly(status);\n\t      } else {\n\t        status.isReadOnly = store.options.isReadOnly;\n\t      }\n\t      return status;\n\t    }\n\t  }]);\n\t\n\t  return FormStore;\n\t}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'isReady', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return false;\n\t  }\n\t}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'isLoading', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return false;\n\t  }\n\t}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'isSaving', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return false;\n\t  }\n\t}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'serverError', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return null;\n\t  }\n\t}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'data', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return {};\n\t  }\n\t}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, 'dataErrors', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return {};\n\t  }\n\t}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, 'saveNotification', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return { active: false, status: null };\n\t  }\n\t}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, 'propertyBeingEdited', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return null;\n\t  }\n\t}), _applyDecoratedDescriptor(_class.prototype, 'status', [_mobx.computed], Object.getOwnPropertyDescriptor(_class.prototype, 'status'), _class.prototype)), _class);\n\texports.default = FormStore;\n\tmodule.exports = exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** FormStore.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1612a96f2dcaf803ffcd\n **/","import { observable, observe, autorun, autorunAsync, action, computed, asMap, isComputedProp } from 'mobx';\n\nconst DEFAULT_SERVER_ERROR_MESSAGE = 'Lost connection to server';\n\nconst getFieldErrors = (tempData) => {\n  const errorsArray = [];\n  Object.keys(tempData).forEach((key) => {\n    if (tempData[key] && typeof tempData[key] === 'object') {\n      return getFieldErrors(tempData[key]);\n    } else if (tempData[key]) {\n      errorsArray.push(tempData[key]);\n    }\n    return tempData[key];\n  });\n  return errorsArray;\n};\n\nfunction isSame(val1, val2) {\n  /* eslint-disable eqeqeq */\n  return val1 == val2 || (val1 instanceof Date && val2 instanceof Date && val1.valueOf() == val2.valueOf());\n  /* eslint-enable eqeqeq */\n}\n\n/**\n * Observes data and if changes come, add them to dataChanges,\n * unless it resets back to dataServer value, then clear that change\n * @this {FormStore}\n * @param {Object} change\n * @param {String} change.name - name of property that changed\n * @param {*} change.newValue\n */\nfunction observableChanged(change) {\n  const store = this;\n  action(() => {\n    store.dataChanges.set(change.name, change.newValue);\n\n    if (store.isSame(store.dataChanges.get(change.name), store.dataServer[change.name])) {\n      store.dataChanges.delete(change.name);\n    }\n  })();\n}\n\n/**\n * Sets up observation on all computed data properties, if any\n * @param {FormStore} store\n */\nfunction observeComputedProperties(store) {\n  store.observeComputedPropertiesDisposers.forEach((f) => f());\n  store.observeComputedPropertiesDisposers = [];\n  action(() => {\n    Object.getOwnPropertyNames(store.data).forEach((key) => {\n      if (isComputedProp(store.data, key)) {\n        store.options.log(`[${store.options.name}] Observing computed property: ${key}`);\n        const disposer = observe(store.data, key, ({ newValue }) => store.storeDataChanged({ name: key, newValue }));\n        store.observeComputedPropertiesDisposers.push(disposer);\n        // add or delete from dataChanges depending on whether value is same as in dataServer:\n        store.storeDataChanged({ name: key, newValue: store.data[key] });\n      }\n    });\n  })();\n}\n\n/**\n * Records successfully saved data as saved\n * and reverts fields server indicates to be in error\n * @param {FormStore} store\n * @param {Object} updates - what we sent to the server\n * @param {Object} response\n * @param {String} [response.data] - optional updated data to merge into the store (server.create can return id here)\n * @param {String} [response.status] - 'error' indicates one or more fields were invalid and not saved.\n * @param {String|Object} [response.error] - either a single error message to show to user if string or field-specific error messages if object\n * @param {String|Array} [response.error_field] - name of the field (or array of field names) in error\n * If autoSave is enabled, any field in error_field for which there is no error message in response.error will be reverted\n * to prevent autoSave from endlessly trying to save the changed field.\n * @returns response.status\n */\nasync function processSaveResponse(store, updates, response) {\n  // TODO add correct updates deleting after errors. updates[field] inner objects\n  store.options.log(`[${store.options.name}] Response received from server.`);\n\n  if (response.status === 'error') {\n    action(() => {\n      let errorFields = [];\n      if (response.error) {\n        if (typeof response.error === 'string') {\n          store.serverError = response.error;\n        } else {\n          Object.assign(store.dataErrors, response.error);\n          errorFields = Object.keys(response.error);\n        }\n      }\n\n      // Supports an array of field names in error_field or a string\n      errorFields = errorFields.concat(response.error_field);\n      errorFields.forEach((field) => {\n        if (store.options.autoSaveInterval && !store.dataErrors[field] && store.isSame(updates[field], store.data[field])) {\n          store.data[field] = store.dataServer[field]; // revert or it'll keep trying to autosave it\n        }\n        delete updates[field]; // don't save it as the new dataServer value\n      });\n    })();\n  } else {\n    store.serverError = null;\n  }\n\n  Object.assign(store.dataServer, updates);\n\n  action(() => {\n    if (response.data) {\n      Object.assign(store.dataServer, response.data);\n      Object.assign(store.data, response.data);\n    }\n\n    for (const [key, value] of Array.from(store.dataChanges)) {\n      if (store.isSame(value, store.dataServer[key])) {\n        store.dataChanges.delete(key);\n      }\n    }\n  })();\n\n  if (typeof store.options.afterSave === 'function') {\n    await store.options.afterSave(store, updates, response);\n  }\n\n  return response.status;\n}\n\n/**\n * @param {FormStore} store\n * @param {Error} err\n */\nfunction handleError(store, err) {\n  if (typeof store.options.server.errorMessage === 'function') {\n    store.serverError = store.options.server.errorMessage(err);\n  } else {\n    store.serverError = store.options.server.errorMessage;\n  }\n\n  store.options.logError(err);\n}\n\nclass FormStore {\n  /** @private */\n  options = {\n    name: 'FormStore', // used in log statements\n    idProperty: null,\n    autoSaveOptions: { skipPropertyBeingEdited: true, keepServerError: true },\n    autoSaveInterval: 0, // in ms\n    minRefreshInterval: 0, // in ms\n    log: function noop() {},\n    logError: console.error.bind(console), // eslint-disable-line\n    /** @type {Boolean|function(object): Boolean} passed status object */\n    isReadOnly: (status) => !status.isReady,\n    server: {\n      /** @type {undefined|function: Promise|Object} - MUST resolve to an object with all data properties present even if all have null values */\n      get: undefined,\n      /** @type {undefined|function(object): Promise|Object} passed updates object - see processSaveResponse for expected error response properties */\n      set: undefined,\n      /** @type {undefined|function(object}: Promise|Object} passed updates object - see processSaveResponse for expected error response properties */\n      create: undefined,\n      /** @type {String|function(error): String} passed error object */\n      errorMessage: DEFAULT_SERVER_ERROR_MESSAGE,\n    },\n    /** @type {undefined|function(FormStore): Promise|Boolean} passed store instance - if it returns false, no refresh will be performed */\n    beforeRefresh: undefined,\n    /** @type {undefined|function(FormStore): Promise} passed store instance */\n    afterRefresh: undefined,\n    /** @type {undefined|function(FormStore, object, object): Promise|Boolean} passed store instance, updates object and saveOptions object,\n     * (i.e. with skipPropertyBeingEdited, etc booleans) - if it returns false, no save will be performed */\n    beforeSave: undefined,\n    /** @type {undefined|function(FormStore, object, object): Promise} passed store instance, updates object and response object\n     * - updates object will already have fields removed from it that response indicates are in error */\n    afterSave: undefined,\n  };\n\n  /**\n   * @private\n   * @type {null|Date}\n   */\n  lastSync = null;\n  /** @private */\n  saveQueue = Promise.resolve();\n  /** @private */\n  observeDataObjectDisposer;\n  /** @private */\n  observeDataPropertiesDisposer;\n  /**\n   * @private\n   * @type {Array<Function>}\n   */\n  observeComputedPropertiesDisposers = [];\n  /** @private */\n  autorunDisposer;\n\n  /** @private */\n  @observable isReady = false; // true after initial data load (refresh) has completed\n  /** @private */\n  @observable isLoading = false;\n  /** @private */\n  @observable isSaving = false;\n  /** @private */\n  @observable serverError = null; // stores both communication error and any explicit response.error returned to save\n\n  /** @private */\n  // To support both Mobx 2.2+ and 3+, this is now done in constructor:\n  // @observable dataChanges = asMap(); // changes that will be sent to server\n\n  /** @private */\n  dataServer = {}; // data returned by the server (kept for checking old values)\n\n  @observable data = {};\n  // stores validation error message if any for each field (data structure is identical to data)\n  @observable dataErrors = {};\n  // active is set to true right after a save is completed and status is set to response.status\n  // this allows a confirmation message to be shown to user and to drive its dismissal,\n  // UI can set this observable's active property back to false.\n  @observable saveNotification = { active: false, status: null };\n  @observable propertyBeingEdited = null; // property currently being edited as set by startEditing()\n\n  isSame = isSame;\n\n  constructor(options, data) {\n    const store = this;\n    Object.assign(store.options, options);\n    if (!data && typeof store.options.server.get !== 'function') {\n      throw new Error('options must specify server get function or supply initial data object to constructor');\n    }\n    if (!typeof store.options.server.create !== 'function' && typeof store.options.server.set !== 'function') {\n      throw new Error('options must specify server set and/or create function(s)');\n    }\n    store.options.server.errorMessage = store.options.server.errorMessage || DEFAULT_SERVER_ERROR_MESSAGE;\n\n    // Supports both Mobx 3+ (observable.map) and 2.x (asMap) without deprecation warnings:\n    store.dataChanges = observable.map ? observable.map() : asMap(); // changes that will be sent to server\n\n    // register observe for changes to properties in store.data as well as to complete replacement of store.data object\n    store.storeDataChanged = observableChanged.bind(store);\n    store.observeDataPropertiesDisposer = observe(store.data, store.storeDataChanged);\n    store.observeDataObjectDisposer = observe(store, 'data', () => {\n      store.observeDataPropertiesDisposer && store.observeDataPropertiesDisposer();\n      store.observeDataPropertiesDisposer = observe(store.data, store.storeDataChanged);\n\n      store.dataChanges.clear();\n      action(() => {\n        Object.keys(store.data).forEach((key) => {\n          const value = store.data[key];\n          if (!store.isSame(value, store.dataServer[key])) {\n            store.dataChanges.set(key, value);\n          }\n        });\n        observeComputedProperties(store);\n      })();\n    });\n\n    store.configAutoSave(store.options.autoSaveInterval, store.options.autoSaveOptions);\n\n    if (data) {\n      store.dataServer = data;\n      store.reset();\n      observeComputedProperties(store);\n      store.isReady = true;\n    }\n  }\n\n  /**\n   *  disposes of all internal observation/autoruns so this instance can be garbage-collected.\n   */\n  dispose() {\n    const store = this;\n    store.autorunDisposer && store.autorunDisposer();\n    store.observeDataObjectDisposer && store.observeDataObjectDisposer();\n    store.observeDataPropertiesDisposer && store.observeDataPropertiesDisposer();\n    store.observeComputedPropertiesDisposers.forEach((f) => f());\n    store.autorunDisposer = undefined;\n    store.observeDataObjectDisposer = undefined;\n    store.observeDataPropertiesDisposer = undefined;\n    store.observeComputedPropertiesDisposers = [];\n  }\n\n  /**\n   * Configures and enables or disables auto-save\n   * @param {Number} autoSaveInterval - (in ms) - if non-zero autosave will be enabled, otherwise disabled\n   * @param {Object} [autoSaveOptions] - overrides the default autoSaveOptions if provided\n   */\n  configAutoSave(autoSaveInterval, autoSaveOptions) {\n    const store = this;\n    store.autorunDisposer && store.autorunDisposer();\n    store.options.autoSaveInterval = autoSaveInterval;\n    store.options.autoSaveOptions = autoSaveOptions || store.options.autoSaveOptions;\n\n    // auto-save by observing dataChanges keys\n    if (store.options.autoSaveInterval) {\n      // Supports both Mobx <=3 (autorunAsync) and Mobx 4+\n      // (ObservableMap keys no longer returning an Array is used to detect Mobx 4+,\n      // because in non-production build autorunAsync exists in 4.x to issue deprecation error)\n      const asyncAutorun = Array.isArray(store.dataChanges.keys()) ? autorunAsync : (fn, delay) => autorun(fn, { delay });\n\n      store.autorunDisposer = asyncAutorun(() => {\n        if ((!store.options.idProperty || store.data[store.options.idProperty]) && Array.from(store.dataChanges).length) {\n          store.options.log(`[${store.options.name}] Auto-save started...`);\n          store.save(store.options.autoSaveOptions);\n        }\n      }, store.options.autoSaveInterval);\n    } else {\n      store.autorunDisposer = undefined;\n    }\n  }\n\n  /**\n   * Marks data property as edit-in-progress and therefore it should not be autosaved - to be called on field focus\n   * @param {String|Array} name - field/property name (Array format supports json schema forms)\n   */\n  startEditing(name) {\n    const store = this;\n    store.propertyBeingEdited = Array.isArray(name) ? name[0] : name;\n  }\n\n  // to be called on field blur, any field name parameter is ignored\n  stopEditing() {\n    const store = this;\n    store.propertyBeingEdited = null;\n    if (store.status.hasChanges) {\n      // This will trigger autorun in case it already ran while we were editing:\n      action(() => {\n        // In MobX 4+, ObservableMap.keys() returns an Iterable, not an array\n        const key = Array.from(store.dataChanges)[0][0];\n        const value = store.dataChanges.get(key);\n        store.dataChanges.delete(key);\n        store.dataChanges.set(key, value);\n      })();\n    }\n  }\n\n  /**\n   * Returns the value of a field/property, optionally returning the last saved value for not validated/in progress fields\n   * Without validated:true, using this function is not necessary, can just access store.data[name].\n   * @param {String|Array} name - field/property name (Array format supports json schema forms)\n   * @param {Boolean} [validated] - only return validated value, i.e. if it's in error, fallback to dataServer\n   * @param {Boolean} [skipPropertyBeingEdited] - used only when validated is true to again fallback to dataServer\n   * @returns {*}\n   */\n  getValue(name, validated, skipPropertyBeingEdited) {\n    const store = this;\n    const prop = Array.isArray(name) ? name[0] : name;\n    if (validated) {\n      // check if property is being edited or invalid\n      if ((skipPropertyBeingEdited && prop === store.propertyBeingEdited) || store.dataErrors[prop]) {\n        return store.dataServer[prop];\n      }\n    }\n    return store.data[prop];\n  }\n\n  // Returns the last saved (or server-provided) set of data\n  // - in an afterSave callback it already includes merged updates that were not in error\n  getSavedData() {\n    const store = this;\n    return store.dataServer;\n  }\n\n  /**\n   * @returns {{errors: Array<String>, isReady: Boolean, isInProgress: Boolean, canSave: Boolean, hasChanges: Boolean, isReadOnly: Boolean}}\n   * errors is an array of any serverError plus all the error messages from all fields (in no particular order)\n   * (serverError is either the string returned in response.error or a communication error and is cleared on every refresh and save)\n   * isReady indicates initial data load (refresh) has been completed and user can start entering data\n   * isInProgress indicates either a refresh or a save is in progress\n   * canSave is true when no refresh or save is in progress and there are no validation errors\n   * hasChanges is true when one or more data properties has a value that's different from last-saved/server-loaded data.\n   * isReadOnly by default is true when isReady is false but can be set to the return value of an\n   *            optional callback to which this status object (without isReadOnly) is passed\n   */\n  @computed get status() {\n    const store = this;\n    let errors = [];\n\n    if (store.serverError) {\n      errors = [store.serverError];\n    }\n\n    errors = errors.concat(getFieldErrors(store.dataErrors));\n\n    const status = {\n      errors,\n      isReady: store.isReady,\n      isInProgress: store.isLoading || store.isSaving,\n      canSave: !store.isLoading && !store.isSaving && (store.serverError ? errors.length === 1 : errors.length === 0),\n      hasChanges: !!store.dataChanges.size,\n    };\n    if (typeof store.options.isReadOnly === 'function') {\n      status.isReadOnly = store.options.isReadOnly(status);\n    } else {\n      status.isReadOnly = store.options.isReadOnly;\n    }\n    return status;\n  }\n\n  /**\n   * Copies dataServer into data and resets the error observable.\n   * Mostly for internal use by refresh().\n   * @param {Object} [data] Optionally set store.data to this object instead of copying dataServer\n   */\n  reset(data) {\n    const store = this;\n\n    action(() => {\n      store.data = data || Object.assign({}, store.dataServer);\n\n      // setup error observable\n      const temporaryDataErrors = {};\n      const setErrorFields = (currentDataFields, temp) => {\n        Object.keys(currentDataFields).forEach((key) => {\n          if (currentDataFields[key] && typeof currentDataFields[key] === 'object') {\n            temp[key] = {};\n            return setErrorFields(currentDataFields[key], temp[key]);\n          }\n          temp[key] = null;\n          return temp[key];\n        });\n      };\n      setErrorFields(store.data, temporaryDataErrors);\n      store.dataErrors = temporaryDataErrors;\n    })();\n  }\n\n  /**\n   * Loads data from server unless a refresh was performed within the last minRefreshInterval (i.e. 15 minutes).\n   * If there are pending (and ready to save) changes, triggers save instead and 'resets the clock' on minRefreshInterval.\n   * For a store with idProperty defined, if that data property is falsy, loads from server only the very first time refresh() is called.\n   * @returns {Promise|Boolean} resolves to true if refresh actually performed, false if skipped\n   */\n  async refresh() {\n    const store = this;\n    if (!store.options.server.get || (store.isReady && store.options.idProperty && !store.data[store.options.idProperty])) {\n      return false;\n    }\n    store.options.log(`[${store.options.name}] Starting data refresh...`);\n\n    if (store.isLoading) {\n      store.options.log(`[${store.options.name}] Data is already being refreshed.`);\n      return false;\n    }\n\n    const now = new Date();\n    const past = new Date(Date.now() - store.options.minRefreshInterval);\n\n    // check if lastSync is between now and 15 minutes ago\n    if (past < store.lastSync && store.lastSync <= now) {\n      store.options.log(`[${store.options.name}] Data refreshed within last ${store.options.minRefreshInterval / 1000} seconds.`);\n      return false;\n    }\n\n    if (store.status.hasChanges && (!store.options.idProperty || store.data[store.options.idProperty])) {\n      store.options.log(`[${store.options.name}] Unsaved changes detected...`);\n\n      if (await store.save()) {\n        store.options.log(`[${store.options.name}] Postponing refresh for ${store.options.minRefreshInterval / 1000} seconds.`);\n        store.lastSync = new Date();\n        return false;\n      }\n    }\n\n    if (typeof store.options.beforeRefresh === 'function') {\n      if (await store.options.beforeRefresh(store) === false) {\n        return false;\n      }\n    }\n\n    store.options.log(`[${store.options.name}] Refreshing data...`);\n    store.isLoading = true;\n\n    try {\n      const result = await store.options.server.get();\n      store.options.log(`[${store.options.name}] Data received from server.`);\n\n      action(() => {\n        store.dataServer = result;\n        store.serverError = null;\n        store.lastSync = new Date();\n        store.reset();\n      })();\n\n      if (typeof store.options.afterRefresh === 'function') {\n        await store.options.afterRefresh(store);\n      }\n\n      observeComputedProperties(store);\n\n      store.options.log(`[${store.options.name}] Refresh finished.`);\n      if (!store.isReady) store.isReady = true;\n    } catch (err) {\n      handleError(store, err);\n    }\n\n    store.isLoading = false;\n    return true;\n  }\n\n  /**\n   * Sends ready-to-save data changes to the server (normally using server.set unless it's undefined, then with server.create)\n   * For a store with idProperty defined when that property is falsy and allowCreate=true, uses server.create instead.\n   * Calls to save() while one is in progress are queued.\n   * @param {Object} saveOptions - the object as a whole is also passed to the beforeSave callback\n   * @param {Boolean} [saveOptions.allowCreate=false] - for a store with idProperty defined, this must be true\n   *                                                    for the save to actually be performed when that property is falsy.\n   * @param {Boolean} [saveOptions.saveAll=false] - normally save only sends changes and if no changes, no save is done.\n   *                                                if saveAll=true, sends the full data object regardless of changes.\n   * @param {Boolean} [saveOptions.skipPropertyBeingEdited=false] - true in an auto-save\n   * @param {Boolean} [saveOptions.keepServerError=false] - true in an auto-save\n   * @returns {Promise|Boolean} resolves to true if save actually performed, false if skipped\n   */\n  save(saveOptions = {}) {\n    const { allowCreate = false, saveAll = false, skipPropertyBeingEdited = false, keepServerError = false } = saveOptions;\n    const store = this;\n\n    store.saveQueue = store.saveQueue.then(\n      async () => {\n        if (store.options.idProperty && !store.data[store.options.idProperty] && !allowCreate) {\n          return false;\n        }\n        store.options.log(`[${store.options.name}] Starting data save...`);\n\n        let updates;\n        if (saveAll) {\n          updates = {};\n          Object.getOwnPropertyNames(store.data).forEach((key) => { if (key[0] !== '$') updates[key] = store.data[key]; });\n        } else {\n          // Mobx 4+ toJS() exports a Map, not an Object and toJSON is the 'legacy' method to export an Object\n          updates = store.dataChanges.toJSON ? store.dataChanges.toJSON() : store.dataChanges.toJS();\n\n          if (Object.keys(updates).length === 0) {\n            store.options.log(`[${store.options.name}] No changes to save.`);\n            return false;\n          }\n\n          // check if we have property currently being edited in changes\n          // or if a property has an error\n          Object.keys(updates).forEach((property) => {\n            if (skipPropertyBeingEdited && property === store.propertyBeingEdited) {\n              store.options.log(`[${store.options.name}] Property \"${property}\" is being edited.`);\n              delete updates[property];\n              return;\n            }\n\n            if (store.dataErrors[property]) {\n              store.options.log(`[${store.options.name}] Property \"${property}\" is not validated.`);\n              delete updates[property];\n              return;\n            }\n\n            if (store.isSame(updates[property], store.dataServer[property])) {\n              store.options.log(`[${store.options.name}] Property \"${property}\" is same as on the server.`);\n              delete updates[property];\n              store.dataChanges.delete(property);\n            }\n          });\n\n          if (Object.keys(updates).length === 0) {\n            store.options.log(`[${store.options.name}] No changes ready to save.`);\n            return false;\n          }\n        }\n\n        if (typeof store.options.beforeSave === 'function') {\n          if (await store.options.beforeSave(store, updates, saveOptions) === false) {\n            return false;\n          }\n        }\n\n        store.options.log(`[${store.options.name}] Saving data...`);\n        store.options.log(updates);\n        store.isSaving = true;\n\n        try {\n          if (!keepServerError) {\n            store.serverError = null;\n          }\n\n          let response;\n          if (store.options.server.set && (!store.options.idProperty || !store.options.server.create || store.data[store.options.idProperty])) {\n            response = await store.options.server.set(updates);\n          } else {\n            response = await store.options.server.create(updates);\n          }\n\n          store.saveNotification.status = await processSaveResponse(store, updates, response);\n          store.saveNotification.active = true;\n\n          store.options.log(`[${store.options.name}] Save finished.`);\n        } catch (err) {\n          handleError(store, err);\n        }\n\n        store.isSaving = false;\n        return true;\n      }\n    );\n\n    return store.saveQueue;\n  }\n}\n\nexport default FormStore;\n\n\n\n/** WEBPACK FOOTER **\n ** B:/job/forked/mobx-form-store/src/FormStore.js\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mobx\"\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}