{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 30e3ea0459ab4c4eab04","webpack:///B:/job/forked/mobx-form-store/src/FormStore.js","webpack:///./~/process/browser.js","webpack:///external \"mobx\""],"names":["DEFAULT_SERVER_ERROR_MESSAGE","getFieldErrors","tempData","errorsArray","Object","keys","forEach","key","push","isSame","val1","val2","Date","valueOf","observableChanged","change","store","dataChanges","set","name","newValue","get","dataServer","delete","observeComputedProperties","observeComputedPropertiesDisposers","f","getOwnPropertyNames","data","options","log","disposer","storeDataChanged","processSaveResponse","updates","response","status","errorFields","error","serverError","assign","dataErrors","concat","error_field","field","autoSaveInterval","Array","from","value","afterSave","handleError","err","server","errorMessage","logError","FormStore","idProperty","autoSaveOptions","skipPropertyBeingEdited","keepServerError","minRefreshInterval","noop","console","bind","isReadOnly","isReady","undefined","create","beforeRefresh","afterRefresh","beforeSave","lastSync","saveQueue","Promise","resolve","Error","observable","map","observeDataPropertiesDisposer","observeDataObjectDisposer","clear","configAutoSave","reset","autorunDisposer","asyncAutorun","isArray","autorunAsync","fn","delay","length","save","propertyBeingEdited","hasChanges","validated","prop","temporaryDataErrors","setErrorFields","currentDataFields","temp","isLoading","now","past","result","saveOptions","allowCreate","saveAll","then","toJSON","toJS","property","isSaving","saveNotification","active","errors","isInProgress","canSave","size","computed"],"mappings":"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AkB,CAApG,CAJI;AAKbG,qBAAY,CAAC,CAAC5E,MAAMC,WAAN,CAAkBmG;AALnB,QAAf;AAOA,WAAI,OAAOpG,MAAMa,OAAN,CAAcmC,UAArB,KAAoC,UAAxC,EAAoD;AAClD5B,gBAAO4B,UAAP,GAAoBhD,MAAMa,OAAN,CAAcmC,UAAd,CAAyB5B,MAAzB,CAApB;AACD,QAFD,MAEO;AACLA,gBAAO4B,UAAP,GAAoBhD,MAAMa,OAAN,CAAcmC,UAAlC;AACD;AACD,cAAO5B,MAAP;AACD;;;;6EAvMAwC,gB;;;YAAqB,K;;8EAErBA,gB;;;YAAuB,K;;6EAEvBA,gB;;;YAAsB,K;;gFAEtBA,gB;;;YAAyB,I;;yEASzBA,gB;;;YAAkB,E;;+EAElBA,gB;;;YAAwB,E;;qFAIxBA,gB;;;YAA8B,EAAEoC,QAAQ,KAAV,EAAiB5E,QAAQ,IAAzB,E;;wFAC9BwC,gB;;;YAAiC,I;;4DA0JjCyC,c;mBAsOY9D,S;;;;;;;;ACzlBf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;;AAErC;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACvLtC,gD","file":"FormStore.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"mobx\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"FormStore\", [\"mobx\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FormStore\"] = factory(require(\"mobx\"));\n\telse\n\t\troot[\"FormStore\"] = factory(root[\"mobx\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 30e3ea0459ab4c4eab04\n **/","import { observable, observe, autorun, autorunAsync, action, computed, asMap, isComputedProp } from 'mobx';\n\nconst DEFAULT_SERVER_ERROR_MESSAGE = 'Lost connection to server';\n\nconst getFieldErrors = (tempData) => {\n  const errorsArray = [];\n  Object.keys(tempData).forEach((key) => {\n    if (tempData[key] && typeof tempData[key] === 'object') {\n      return getFieldErrors(tempData[key]);\n    } else if (tempData[key]) {\n      errorsArray.push(tempData[key]);\n    }\n    return tempData[key];\n  });\n  return errorsArray;\n};\n\nfunction isSame(val1, val2) {\n  /* eslint-disable eqeqeq */\n  return val1 == val2 || (val1 instanceof Date && val2 instanceof Date && val1.valueOf() == val2.valueOf());\n  /* eslint-enable eqeqeq */\n}\n\n/**\n * Observes data and if changes come, add them to dataChanges,\n * unless it resets back to dataServer value, then clear that change\n * @this {FormStore}\n * @param {Object} change\n * @param {String} change.name - name of property that changed\n * @param {*} change.newValue\n */\nfunction observableChanged(change) {\n  const store = this;\n  action(() => {\n    store.dataChanges.set(change.name, change.newValue);\n\n    if (store.isSame(store.dataChanges.get(change.name), store.dataServer[change.name])) {\n      store.dataChanges.delete(change.name);\n    }\n  })();\n}\n\n/**\n * Sets up observation on all computed data properties, if any\n * @param {FormStore} store\n */\nfunction observeComputedProperties(store) {\n  store.observeComputedPropertiesDisposers.forEach((f) => f());\n  store.observeComputedPropertiesDisposers = [];\n  action(() => {\n    Object.getOwnPropertyNames(store.data).forEach((key) => {\n      if (isComputedProp(store.data, key)) {\n        store.options.log(`[${store.options.name}] Observing computed property: ${key}`);\n        const disposer = observe(store.data, key, ({ newValue }) => store.storeDataChanged({ name: key, newValue }));\n        store.observeComputedPropertiesDisposers.push(disposer);\n        // add or delete from dataChanges depending on whether value is same as in dataServer:\n        store.storeDataChanged({ name: key, newValue: store.data[key] });\n      }\n    });\n  })();\n}\n\n/**\n * Records successfully saved data as saved\n * and reverts fields server indicates to be in error\n * @param {FormStore} store\n * @param {Object} updates - what we sent to the server\n * @param {Object} response\n * @param {String} [response.data] - optional updated data to merge into the store (server.create can return id here)\n * @param {String} [response.status] - 'error' indicates one or more fields were invalid and not saved.\n * @param {String|Object} [response.error] - either a single error message to show to user if string or field-specific error messages if object\n * @param {String|Array} [response.error_field] - name of the field (or array of field names) in error\n * If autoSave is enabled, any field in error_field for which there is no error message in response.error will be reverted\n * to prevent autoSave from endlessly trying to save the changed field.\n * @returns response.status\n */\nasync function processSaveResponse(store, updates, response) {\n  // TODO add correct updates deleting after errors. updates[field] inner objects\n  store.options.log(`[${store.options.name}] Response received from server.`);\n\n  if (response.status === 'error') {\n    action(() => {\n      let errorFields = [];\n      if (response.error) {\n        if (typeof response.error === 'string') {\n          store.serverError = response.error;\n        } else {\n          Object.assign(store.dataErrors, response.error);\n          errorFields = Object.keys(response.error);\n        }\n      }\n\n      // Supports an array of field names in error_field or a string\n      errorFields = errorFields.concat(response.error_field);\n      errorFields.forEach((field) => {\n        if (store.options.autoSaveInterval && !store.dataErrors[field] && store.isSame(updates[field], store.data[field])) {\n          store.data[field] = store.dataServer[field]; // revert or it'll keep trying to autosave it\n        }\n        delete updates[field]; // don't save it as the new dataServer value\n      });\n    })();\n  } else {\n    store.serverError = null;\n  }\n\n  Object.assign(store.dataServer, updates);\n\n  action(() => {\n    if (response.data) {\n      Object.assign(store.dataServer, response.data);\n      Object.assign(store.data, response.data);\n    }\n\n    for (const [key, value] of Array.from(store.dataChanges)) {\n      if (store.isSame(value, store.dataServer[key])) {\n        store.dataChanges.delete(key);\n      }\n    }\n  })();\n\n  if (typeof store.options.afterSave === 'function') {\n    await store.options.afterSave(store, updates, response);\n  }\n\n  return response.status;\n}\n\n/**\n * @param {FormStore} store\n * @param {Error} err\n */\nfunction handleError(store, err) {\n  if (typeof store.options.server.errorMessage === 'function') {\n    store.serverError = store.options.server.errorMessage(err);\n  } else {\n    store.serverError = store.options.server.errorMessage;\n  }\n\n  store.options.logError(err);\n}\n\nclass FormStore {\n  /** @private */\n  options = {\n    name: 'FormStore', // used in log statements\n    idProperty: null,\n    autoSaveOptions: { skipPropertyBeingEdited: true, keepServerError: true },\n    autoSaveInterval: 0, // in ms\n    minRefreshInterval: 0, // in ms\n    log: function noop() {},\n    logError: console.error.bind(console), // eslint-disable-line\n    /** @type {Boolean|function(object): Boolean} passed status object */\n    isReadOnly: (status) => !status.isReady,\n    server: {\n      /** @type {undefined|function: Promise|Object} - MUST resolve to an object with all data properties present even if all have null values */\n      get: undefined,\n      /** @type {undefined|function(object): Promise|Object} passed updates object - see processSaveResponse for expected error response properties */\n      set: undefined,\n      /** @type {undefined|function(object}: Promise|Object} passed updates object - see processSaveResponse for expected error response properties */\n      create: undefined,\n      /** @type {String|function(error): String} passed error object */\n      errorMessage: DEFAULT_SERVER_ERROR_MESSAGE,\n    },\n    /** @type {undefined|function(FormStore): Promise|Boolean} passed store instance - if it returns false, no refresh will be performed */\n    beforeRefresh: undefined,\n    /** @type {undefined|function(FormStore): Promise} passed store instance */\n    afterRefresh: undefined,\n    /** @type {undefined|function(FormStore, object, object): Promise|Boolean} passed store instance, updates object and saveOptions object,\n     * (i.e. with skipPropertyBeingEdited, etc booleans) - if it returns false, no save will be performed */\n    beforeSave: undefined,\n    /** @type {undefined|function(FormStore, object, object): Promise} passed store instance, updates object and response object\n     * - updates object will already have fields removed from it that response indicates are in error */\n    afterSave: undefined,\n  };\n\n  /**\n   * @private\n   * @type {null|Date}\n   */\n  lastSync = null;\n  /** @private */\n  saveQueue = Promise.resolve();\n  /** @private */\n  observeDataObjectDisposer;\n  /** @private */\n  observeDataPropertiesDisposer;\n  /**\n   * @private\n   * @type {Array<Function>}\n   */\n  observeComputedPropertiesDisposers = [];\n  /** @private */\n  autorunDisposer;\n\n  /** @private */\n  @observable isReady = false; // true after initial data load (refresh) has completed\n  /** @private */\n  @observable isLoading = false;\n  /** @private */\n  @observable isSaving = false;\n  /** @private */\n  @observable serverError = null; // stores both communication error and any explicit response.error returned to save\n\n  /** @private */\n  // To support both Mobx 2.2+ and 3+, this is now done in constructor:\n  // @observable dataChanges = asMap(); // changes that will be sent to server\n\n  /** @private */\n  dataServer = {}; // data returned by the server (kept for checking old values)\n\n  @observable data = {};\n  // stores validation error message if any for each field (data structure is identical to data)\n  @observable dataErrors = {};\n  // active is set to true right after a save is completed and status is set to response.status\n  // this allows a confirmation message to be shown to user and to drive its dismissal,\n  // UI can set this observable's active property back to false.\n  @observable saveNotification = { active: false, status: null };\n  @observable propertyBeingEdited = null; // property currently being edited as set by startEditing()\n\n  isSame = isSame;\n\n  constructor(options, data) {\n    const store = this;\n    Object.assign(store.options, options);\n    if (!data && typeof store.options.server.get !== 'function') {\n      throw new Error('options must specify server get function or supply initial data object to constructor');\n    }\n    if (!typeof store.options.server.create !== 'function' && typeof store.options.server.set !== 'function') {\n      throw new Error('options must specify server set and/or create function(s)');\n    }\n    store.options.server.errorMessage = store.options.server.errorMessage || DEFAULT_SERVER_ERROR_MESSAGE;\n\n    // Supports both Mobx 3+ (observable.map) and 2.x (asMap) without deprecation warnings:\n    store.dataChanges = observable.map ? observable.map() : asMap(); // changes that will be sent to server\n\n    // register observe for changes to properties in store.data as well as to complete replacement of store.data object\n    store.storeDataChanged = observableChanged.bind(store);\n    store.observeDataPropertiesDisposer = observe(store.data, store.storeDataChanged);\n    store.observeDataObjectDisposer = observe(store, 'data', () => {\n      store.observeDataPropertiesDisposer && store.observeDataPropertiesDisposer();\n      store.observeDataPropertiesDisposer = observe(store.data, store.storeDataChanged);\n\n      store.dataChanges.clear();\n      action(() => {\n        Object.keys(store.data).forEach((key) => {\n          const value = store.data[key];\n          if (!store.isSame(value, store.dataServer[key])) {\n            store.dataChanges.set(key, value);\n          }\n        });\n        observeComputedProperties(store);\n      })();\n    });\n\n    store.configAutoSave(store.options.autoSaveInterval, store.options.autoSaveOptions);\n\n    if (data) {\n      store.dataServer = data;\n      store.reset();\n      observeComputedProperties(store);\n      store.isReady = true;\n    }\n  }\n\n  /**\n   *  disposes of all internal observation/autoruns so this instance can be garbage-collected.\n   */\n  dispose() {\n    const store = this;\n    store.autorunDisposer && store.autorunDisposer();\n    store.observeDataObjectDisposer && store.observeDataObjectDisposer();\n    store.observeDataPropertiesDisposer && store.observeDataPropertiesDisposer();\n    store.observeComputedPropertiesDisposers.forEach((f) => f());\n    store.autorunDisposer = undefined;\n    store.observeDataObjectDisposer = undefined;\n    store.observeDataPropertiesDisposer = undefined;\n    store.observeComputedPropertiesDisposers = [];\n  }\n\n  /**\n   * Configures and enables or disables auto-save\n   * @param {Number} autoSaveInterval - (in ms) - if non-zero autosave will be enabled, otherwise disabled\n   * @param {Object} [autoSaveOptions] - overrides the default autoSaveOptions if provided\n   */\n  configAutoSave(autoSaveInterval, autoSaveOptions) {\n    const store = this;\n    store.autorunDisposer && store.autorunDisposer();\n    store.options.autoSaveInterval = autoSaveInterval;\n    store.options.autoSaveOptions = autoSaveOptions || store.options.autoSaveOptions;\n\n    // auto-save by observing dataChanges keys\n    if (store.options.autoSaveInterval) {\n      // Supports both Mobx <=3 (autorunAsync) and Mobx 4+\n      // (ObservableMap keys no longer returning an Array is used to detect Mobx 4+,\n      // because in non-production build autorunAsync exists in 4.x to issue deprecation error)\n      const asyncAutorun = Array.isArray(store.dataChanges.keys()) ? autorunAsync : (fn, delay) => autorun(fn, { delay });\n\n      store.autorunDisposer = asyncAutorun(() => {\n        if ((!store.options.idProperty || store.data[store.options.idProperty]) && Array.from(store.dataChanges).length) {\n          store.options.log(`[${store.options.name}] Auto-save started...`);\n          store.save(store.options.autoSaveOptions);\n        }\n      }, store.options.autoSaveInterval);\n    } else {\n      store.autorunDisposer = undefined;\n    }\n  }\n\n  /**\n   * Marks data property as edit-in-progress and therefore it should not be autosaved - to be called on field focus\n   * @param {String|Array} name - field/property name (Array format supports json schema forms)\n   */\n  startEditing(name) {\n    const store = this;\n    store.propertyBeingEdited = Array.isArray(name) ? name[0] : name;\n  }\n\n  // to be called on field blur, any field name parameter is ignored\n  stopEditing() {\n    const store = this;\n    store.propertyBeingEdited = null;\n    if (store.status.hasChanges) {\n      // This will trigger autorun in case it already ran while we were editing:\n      action(() => {\n        // In MobX 4+, ObservableMap.keys() returns an Iterable, not an array\n        const key = Array.from(store.dataChanges)[0][0];\n        const value = store.dataChanges.get(key);\n        store.dataChanges.delete(key);\n        store.dataChanges.set(key, value);\n      })();\n    }\n  }\n\n  /**\n   * Returns the value of a field/property, optionally returning the last saved value for not validated/in progress fields\n   * Without validated:true, using this function is not necessary, can just access store.data[name].\n   * @param {String|Array} name - field/property name (Array format supports json schema forms)\n   * @param {Boolean} [validated] - only return validated value, i.e. if it's in error, fallback to dataServer\n   * @param {Boolean} [skipPropertyBeingEdited] - used only when validated is true to again fallback to dataServer\n   * @returns {*}\n   */\n  getValue(name, validated, skipPropertyBeingEdited) {\n    const store = this;\n    const prop = Array.isArray(name) ? name[0] : name;\n    if (validated) {\n      // check if property is being edited or invalid\n      if ((skipPropertyBeingEdited && prop === store.propertyBeingEdited) || store.dataErrors[prop]) {\n        return store.dataServer[prop];\n      }\n    }\n    return store.data[prop];\n  }\n\n  // Returns the last saved (or server-provided) set of data\n  // - in an afterSave callback it already includes merged updates that were not in error\n  getSavedData() {\n    const store = this;\n    return store.dataServer;\n  }\n\n  /**\n   * @returns {{errors: Array<String>, isReady: Boolean, isInProgress: Boolean, canSave: Boolean, hasChanges: Boolean, isReadOnly: Boolean}}\n   * errors is an array of any serverError plus all the error messages from all fields (in no particular order)\n   * (serverError is either the string returned in response.error or a communication error and is cleared on every refresh and save)\n   * isReady indicates initial data load (refresh) has been completed and user can start entering data\n   * isInProgress indicates either a refresh or a save is in progress\n   * canSave is true when no refresh or save is in progress and there are no validation errors\n   * hasChanges is true when one or more data properties has a value that's different from last-saved/server-loaded data.\n   * isReadOnly by default is true when isReady is false but can be set to the return value of an\n   *            optional callback to which this status object (without isReadOnly) is passed\n   */\n  @computed get status() {\n    const store = this;\n    let errors = [];\n\n    if (store.serverError) {\n      errors = [store.serverError];\n    }\n\n    errors = errors.concat(getFieldErrors(store.dataErrors));\n\n    const status = {\n      errors,\n      isReady: store.isReady,\n      isInProgress: store.isLoading || store.isSaving,\n      canSave: !store.isLoading && !store.isSaving && (store.serverError ? errors.length === 1 : errors.length === 0),\n      hasChanges: !!store.dataChanges.size,\n    };\n    if (typeof store.options.isReadOnly === 'function') {\n      status.isReadOnly = store.options.isReadOnly(status);\n    } else {\n      status.isReadOnly = store.options.isReadOnly;\n    }\n    return status;\n  }\n\n  /**\n   * Copies dataServer into data and resets the error observable.\n   * Mostly for internal use by refresh().\n   * @param {Object} [data] Optionally set store.data to this object instead of copying dataServer\n   */\n  reset(data) {\n    const store = this;\n\n    action(() => {\n      store.data = data || Object.assign({}, store.dataServer);\n\n      // setup error observable\n      const temporaryDataErrors = {};\n      const setErrorFields = (currentDataFields, temp) => {\n        Object.keys(currentDataFields).forEach((key) => {\n          if (currentDataFields[key] && typeof currentDataFields[key] === 'object') {\n            temp[key] = {};\n            return setErrorFields(currentDataFields[key], temp[key]);\n          }\n          temp[key] = null;\n          return temp[key];\n        });\n      };\n      setErrorFields(store.data, temporaryDataErrors);\n      store.dataErrors = temporaryDataErrors;\n    })();\n  }\n\n  /**\n   * Loads data from server unless a refresh was performed within the last minRefreshInterval (i.e. 15 minutes).\n   * If there are pending (and ready to save) changes, triggers save instead and 'resets the clock' on minRefreshInterval.\n   * For a store with idProperty defined, if that data property is falsy, loads from server only the very first time refresh() is called.\n   * @returns {Promise|Boolean} resolves to true if refresh actually performed, false if skipped\n   */\n  async refresh() {\n    const store = this;\n    if (!store.options.server.get || (store.isReady && store.options.idProperty && !store.data[store.options.idProperty])) {\n      return false;\n    }\n    store.options.log(`[${store.options.name}] Starting data refresh...`);\n\n    if (store.isLoading) {\n      store.options.log(`[${store.options.name}] Data is already being refreshed.`);\n      return false;\n    }\n\n    const now = new Date();\n    const past = new Date(Date.now() - store.options.minRefreshInterval);\n\n    // check if lastSync is between now and 15 minutes ago\n    if (past < store.lastSync && store.lastSync <= now) {\n      store.options.log(`[${store.options.name}] Data refreshed within last ${store.options.minRefreshInterval / 1000} seconds.`);\n      return false;\n    }\n\n    if (store.status.hasChanges && (!store.options.idProperty || store.data[store.options.idProperty])) {\n      store.options.log(`[${store.options.name}] Unsaved changes detected...`);\n\n      if (await store.save()) {\n        store.options.log(`[${store.options.name}] Postponing refresh for ${store.options.minRefreshInterval / 1000} seconds.`);\n        store.lastSync = new Date();\n        return false;\n      }\n    }\n\n    if (typeof store.options.beforeRefresh === 'function') {\n      if (await store.options.beforeRefresh(store) === false) {\n        return false;\n      }\n    }\n\n    store.options.log(`[${store.options.name}] Refreshing data...`);\n    store.isLoading = true;\n\n    try {\n      const result = await store.options.server.get();\n      store.options.log(`[${store.options.name}] Data received from server.`);\n\n      action(() => {\n        store.dataServer = result;\n        store.serverError = null;\n        store.lastSync = new Date();\n        store.reset();\n      })();\n\n      if (typeof store.options.afterRefresh === 'function') {\n        await store.options.afterRefresh(store);\n      }\n\n      observeComputedProperties(store);\n\n      store.options.log(`[${store.options.name}] Refresh finished.`);\n      if (!store.isReady) store.isReady = true;\n    } catch (err) {\n      handleError(store, err);\n    }\n\n    store.isLoading = false;\n    return true;\n  }\n\n  /**\n   * Sends ready-to-save data changes to the server (normally using server.set unless it's undefined, then with server.create)\n   * For a store with idProperty defined when that property is falsy and allowCreate=true, uses server.create instead.\n   * Calls to save() while one is in progress are queued.\n   * @param {Object} saveOptions - the object as a whole is also passed to the beforeSave callback\n   * @param {Boolean} [saveOptions.allowCreate=false] - for a store with idProperty defined, this must be true\n   *                                                    for the save to actually be performed when that property is falsy.\n   * @param {Boolean} [saveOptions.saveAll=false] - normally save only sends changes and if no changes, no save is done.\n   *                                                if saveAll=true, sends the full data object regardless of changes.\n   * @param {Boolean} [saveOptions.skipPropertyBeingEdited=false] - true in an auto-save\n   * @param {Boolean} [saveOptions.keepServerError=false] - true in an auto-save\n   * @returns {Promise|Boolean} resolves to true if save actually performed, false if skipped\n   */\n  save(saveOptions = {}) {\n    const { allowCreate = false, saveAll = false, skipPropertyBeingEdited = false, keepServerError = false } = saveOptions;\n    const store = this;\n\n    store.saveQueue = store.saveQueue.then(\n      async () => {\n        if (store.options.idProperty && !store.data[store.options.idProperty] && !allowCreate) {\n          return false;\n        }\n        store.options.log(`[${store.options.name}] Starting data save...`);\n\n        let updates;\n        if (saveAll) {\n          updates = {};\n          Object.getOwnPropertyNames(store.data).forEach((key) => { if (key[0] !== '$') updates[key] = store.data[key]; });\n        } else {\n          // Mobx 4+ toJS() exports a Map, not an Object and toJSON is the 'legacy' method to export an Object\n          updates = store.dataChanges.toJSON ? store.dataChanges.toJSON() : store.dataChanges.toJS();\n\n          if (Object.keys(updates).length === 0) {\n            store.options.log(`[${store.options.name}] No changes to save.`);\n            return false;\n          }\n\n          // check if we have property currently being edited in changes\n          // or if a property has an error\n          Object.keys(updates).forEach((property) => {\n            if (skipPropertyBeingEdited && property === store.propertyBeingEdited) {\n              store.options.log(`[${store.options.name}] Property \"${property}\" is being edited.`);\n              delete updates[property];\n              return;\n            }\n\n            if (store.dataErrors[property]) {\n              store.options.log(`[${store.options.name}] Property \"${property}\" is not validated.`);\n              delete updates[property];\n              return;\n            }\n\n            if (store.isSame(updates[property], store.dataServer[property])) {\n              store.options.log(`[${store.options.name}] Property \"${property}\" is same as on the server.`);\n              delete updates[property];\n              store.dataChanges.delete(property);\n            }\n          });\n\n          if (Object.keys(updates).length === 0) {\n            store.options.log(`[${store.options.name}] No changes ready to save.`);\n            return false;\n          }\n        }\n\n        if (typeof store.options.beforeSave === 'function') {\n          if (await store.options.beforeSave(store, updates, saveOptions) === false) {\n            return false;\n          }\n        }\n\n        store.options.log(`[${store.options.name}] Saving data...`);\n        store.options.log(updates);\n        store.isSaving = true;\n\n        try {\n          if (!keepServerError) {\n            store.serverError = null;\n          }\n\n          let response;\n          if (store.options.server.set && (!store.options.idProperty || !store.options.server.create || store.data[store.options.idProperty])) {\n            response = await store.options.server.set(updates);\n          } else {\n            response = await store.options.server.create(updates);\n          }\n\n          store.saveNotification.status = await processSaveResponse(store, updates, response);\n          store.saveNotification.active = true;\n\n          store.options.log(`[${store.options.name}] Save finished.`);\n        } catch (err) {\n          handleError(store, err);\n        }\n\n        store.isSaving = false;\n        return true;\n      }\n    );\n\n    return store.saveQueue;\n  }\n}\n\nexport default FormStore;\n\n\n\n/** WEBPACK FOOTER **\n ** B:/job/forked/mobx-form-store/src/FormStore.js\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mobx\"\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}